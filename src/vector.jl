import Base: getindex, first, last, length, isempty, iszero, zero, eltype, iterate, IteratorEltype, IteratorSize, show, <, <=, >, >=, ==, Vector # , *, +, -, /, \
import AbstractAlgebra: base_ring
import SparseArrays: SparseVector

"""
    Basis{T} <: AbstractBasis{T}

Ordered basis over a field with variable size, allowing to create new basis elements and delete and replace existing basis elements with vectors with non-zero entries corresponding to basis elements with smaller indices..
"""
mutable struct Basis{E}
    const base_ring::Field
    created::Int
    deleted::Int
    completed::Int
    first_undeleted::Union{Nothing,E}  # first undeleted element
    last_undeleted::Union{Nothing,E}  # last undeleted element
    last::Union{Nothing,E}  # last created element (possibly deleted)
end

"""
    AbstractBasisVector{T<:FieldElement}

Abstract type for vectors over a field generated by a basis of variable size.  
"""
abstract type AbstractBasisVector{T<:FieldElement} end


### basis element

"""
    BasisElement{T} <: AbstractBasisVector{T}

Element of an ordered basis with variable dimension, which may be deleted from the basis and replaced by a vector with entries prior to itself regarding the order on the basis.
"""
mutable struct BasisElement{T}
    const index::Int  # index of the basis element, used for both documentation and ordering of basis elements
    const basis::Basis{BasisElement{T}}

    prev::Union{Nothing,BasisElement{T}}  # previous basis element; nothing if self is deleted, otherwise the value is guaranteed not to be deleted or nothing
    next::Union{Nothing,BasisElement{T}}  # next basis element; guaranteed not to be deleted, if self is not deleted; if self is deleted, this is not nothing unless this is the last basis element defined

    const weight::Int  # weight at which this basis element was created
    const image::Union{Nothing,Tuple{Int,<:FreeAssAlgElem}}  # image of the basis element in debugging mode or nothing
    const entries::Vector{<:AbstractBasisVector{T}}  # action of generators on the basis element
    undefined::Int  # how many entries are nothing

    deleted::Bool
    vector::AbstractBasisVector{T}  # vector representation of this basis element, or its replacement, if it is deleted

    """
        BasisElement(index::Int, basis::B, image::Union{Nothing, Tuple{Int, <:FreeAssAlgElem}}, ngens::Int, weight::Int, prev::Union{Nothing,BasisElement{T}}) where {T, B <: AbstractBasis{T}}

    Create a basis element of `basis` with the specified index, weight and image and the previous basis element `prev`.
    """
    function BasisElement(index::Int, basis::Basis{BasisElement{T}}, image::Union{Nothing,Tuple{Int,<:FreeAssAlgElem}}, ngens::Int, weight::Int, prev::Union{Nothing,BasisElement{T}}) where {T}
        b = new{T}(index, basis, prev, nothing, weight, image, Vector{AbstractBasisVector{T}}(undef, ngens), ngens, false)
        b.vector = LinkedSparseBasisVector(b)
        return b
    end
end

"""
    Basis(k::Field)

Create an empty basis with variable size over the field `k`.
"""
Basis(k::Field) = Basis{BasisElement{elem_type(k)}}(k, 0, 0, 0, nothing, nothing, nothing)


mutable struct BasisVectorEntry{T<:FieldElement}
    const elem::BasisElement{T}
    coeff::T
end

elem(e::BasisVectorEntry) = e.elem
coeff(e::BasisVectorEntry) = e.coeff

include("linkedsparse.jl")


# required for iteration on basis vectors
IteratorSize(::Type{<:AbstractBasisVector}) = Base.SizeUnknown()  # in general size is unkown in advance
IteratorEltype(::Type{<:AbstractBasisVector}) = Base.HasEltype()
eltype(::Type{<:AbstractBasisVector{T}}) where {T} = BasisVectorEntry{T}


# ordering of basis elements within the basis by their indices 
<(b₁::BasisElement, b₂::BasisElement) = b₁.index < b₂.index
<=(b₁::BasisElement, b₂::BasisElement) = b₁.index <= b₂.index
>(b₁::BasisElement, b₂::BasisElement) = b₁.index > b₂.index
>=(b₁::BasisElement, b₂::BasisElement) = b₁.index >= b₂.index
==(b₁::BasisElement, b₂::BasisElement) = b₁.index == b₂.index


"""
    index(b::BasisElement)

Return the index of the basis element `b` in its basis.

This index does not change when basis elements are created or deleted and is unique.
"""
index(b::BasisElement) = b.index


"""
    basis(b::BasisElement) 

Return the parent basis of the basis element `b`.
"""
basis(b::BasisElement) = b.basis


"""
    isdeleted(b::BasisElement)

Return whether the basis element `b` was deleted from its basis and replaced.
"""
isdeleted(b::BasisElement) = b.deleted


"""
    vector(b::BasisElement)

Return the internal vector representation of the basis element `b` or its replacement, if `b` is deleted.
"""
vector(b::BasisElement) = b.vector


"""
    vector(b::BasisElement)

Return the replacement for a deleted basis element `b`.
"""
function replacement(b::BasisElement)
    @assert isdeleted(b)
    return vector(b)
end


"""
    iterate(b::BasisElement, i::Int = 1)

Advance the iterator to obtain the next entry of the internal vector representation of `b` at the iteration state `i` corresponding to an undeleted basis element `b'` with non-zero coefficient `λ` in the internal vector representation of `b`. 
If no entry remains, `nothing` is returned. Otherwise the tuple `((b', λ), i)` with the next iteration state `i` is returned.

This delegates the operation to the respective operation for the internal vector representation of `b`. 

The iteration order is descending regarding the order on the basis. 
"""
# TODO: fix doc string
# iterate(b::BasisElement) = iterate(vector(b))
# iterate(b::BasisElement, state) = iterate(vector(b), state)


"""
    show(io::IO, b::BasisElement)

Write a text representation of the basis element `b` to the output stream `io`.

This delegates the operation to the respective operation for the internal vector representation of `b`. 
"""
show(io::IO, b::BasisElement) = show(io, vector(b))


"""
    zero(b::BasisElement)

Create a mutable vector representing `0` for the basis given by the input.

This delegates the operation to the respective operation for the internal vector representation of `b`. 
"""
zero(b::BasisElement) = zero(vector(b))


"""
    last(b::BasisElement)

Find the last basis element `b'` with non-zero coefficient `λ` in the internal vector representation of `b` regarding the order on the basis and return the tuple `(b', λ)` or return `nothing` if the internal vector representation of `b` is zero. 

This delegates the operation to the respective operation for the internal vector representation of `b`. 
"""
# last(b::BasisElement) = last(vector(b))


"""
    iszero(b::BasisElement)

Return `true` if the internal vector representation of `b` is zero, which may occur, when `b` is deleted from the basis and replaced.

This delegates the operation to the respective operation for the internal vector representation of `b`. 
"""
# iszero(b::BasisElement) = iszero(vector(b))


"""
    add_scaled!(v::AbstractBasisVector{T}, b::BasisElement{T}, λ::T) where {T}

Compute `v := v + c ⋅ b` in-place and return `v`.

This delegates the operation to the respective operation for the internal vector representation of `b` and is only implemented if `v` is mutable.
"""
add_scaled!(v::AbstractBasisVector{T}, b::BasisElement{T}, λ::T) where {T} = add_scaled!(v, vector(b), λ)


"""
    add!(v::AbstractBasisVector{T}, b::BasisElement{T}) where {T}

Compute `v := v + b` in-place and return `v`.

This delegates the operation to the respective operation for the internal vector representation of `b` and is only implemented if `v` is mutable.
"""
add!(v::AbstractBasisVector{T}, b::BasisElement{T}) where {T} = add!(v, vector(b))


"""
    subtract!(v::AbstractBasisVector{T}, b::BasisElement{T}) where {T}

Compute `v := v - b` in-place and return `v`.

This delegates the operation to the respective operation for the internal vector representation of `b` and is only implemented if `v` is mutable. 
"""
subtract!(v::AbstractBasisVector{T}, b::BasisElement{T}) where {T} = subtract!(v, vector(b))


"""
    subscript(n::Int)

Convert `n` to an UTF-8 string of subscript characters.  
"""
subscript(n::Int) = join([Char(0x2080 + parse(Int, d)) for d in string(n)])


"""
    show(io::IO, v::SparseBasisVector)

Write a text representation of the sparse vector `v` to the output stream `io`.

Internally entries of `v` corresponding to deleted basis elements will be replaced recursively by their undeleted replacements, as they are discovered throughout the output generation.
"""
function show(io::IO, v::AbstractBasisVector)
    # display undeleted basis elements only
    if iszero(v)
        print(io, "0")
    else
        l = map(t -> begin
                b = elem(t)
                λ = coeff(t)
                # hide coefficient if is one
                ₛ = subscript(index(b))
                return isone(λ) ? "b$ₛ" : "$λ b$ₛ"
            end, v)
        entries = reverse(l)  # reverse order such that basis elements are in ascending order
        # TODO: fix redundant "+"" signs if the representation of a value starts with "-" and adapt whitespace
        print(io, join(entries, " + "))
    end
end


### basis


"""
    isempty(basis::Basis)

Return `true` if there is no (undeleted) basis element in `basis`.
"""
isempty(basis::Basis) = basis.created == basis.deleted


"""
    base_ring(basis::Basis)

Return the field over which `basis` is constructed.
"""
base_ring(basis::Basis) = basis.base_ring


"""
    first(basis::Basis)

Return the first (undeleted) basis element in `basis` or `nothing` if it is empty.
"""
first(basis::Basis) = basis.first_undeleted


"""
    last(basis::Basis)

Return the last (undeleted) basis element in `basis` or `nothing` if it is empty.
"""
last(basis::Basis) = basis.last_undeleted


"""
    ncreated(basis::Basis)

Return the total count of basis elements created and inserted into `basis`.
"""
ncreated(basis::Basis) = basis.created


"""
    nalive(basis::Basis)

Return the count of (undeleted) basis elements in `basis`.
"""
nalive(basis::Basis) = basis.created - basis.deleted


"""
    ndeleted(basis::Basis)

Return the total count of basis elements deleted from `basis`.
"""
ndeleted(basis::Basis) = basis.deleted


"""
    isclosed(basis::Basis)

Return `true` if for all elements `b` in `basis` the action `b.x` is defined for all generators `x`.
"""
isclosed(basis::Basis) = basis.completed == length(basis)


"""
    length(basis::Basis)

Return the count of (undeleted) basis elements in `basis`.
"""
length(basis::Basis) = basis.created - basis.deleted


"""
    eltype(::Type{Basis{T}}) where {T}

Return the type of elements in a basis.
"""
eltype(::Type{Basis{E}}) where {E} = E


"""
    iterate(basis::Basis)

Start the iterator to obtain the first element `b` together with the new iteration state of `basis` or return `nothing` if `basis` is empty.

The iteration order is ascending regarding the order on the basis. 
"""
iterate(basis::Basis) = isempty(basis) ? nothing : (b = first(basis); (b, b))


"""
    iterate(::Basis{E}, last::E) where {E}

Advance the iterator to obtain the next element `b` of the specified basis at the iteration state `last`.
If no element remains, `nothing` is returned. Otherwise the tuple `(b, b)` with the new iteration state `b` as second value is returned.

The iteration order is ascending regarding the order on the basis. 
"""
iterate(::Basis{E}, last::E) where {E} = hasnext(last) ? (b = next(last); (b, b)) : nothing


"""
    create!(basis::Basis{T}, weight::Int, ngens::Int, img::Union{Nothing, Tuple{Int, <:FreeAssAlgElem}}) where {T}

Create a new basis element with the specified data and insert it into `basis`.
"""
function create!(basis::Basis, weight::Int, ngens::Int, img::Union{Nothing,Tuple{Int,<:FreeAssAlgElem}})
    index = isnothing(basis.last) ? 1 : basis.last.index + 1
    b = BasisElement(index, basis, img, ngens, weight, basis.last_undeleted)  # last undeleted as predecessor of b

    # update forward pointers
    if !isnothing(basis.last_undeleted)
        basis.last_undeleted.next = b
    end
    if !isnothing(basis.last)
        basis.last.next = b
    end

    # update basis
    if isnothing(basis.first_undeleted)
        basis.first_undeleted = b
    end
    basis.last_undeleted = b
    basis.last = b
    basis.created += 1

    return b
end


"""
    delete!(b::BasisElement{T, Basis{T}}, replacement::AbstractBasisVector{T}) where {T}

Delete the basis element `b` from its basis and replace it with a vector `replacement`, which only contains entries corresponding to basis elements prior to `b` regarding the order of the basis.
"""
function delete!(b::BasisElement{T}, replacement::AbstractBasisVector{T}) where {T}
    @assert !isdeleted(b)
    @assert iszero(replacement) || elem(last(replacement)) < b  # all basis elements in the replacement for b must have smaller index than b

    B = basis(b)
    if isnothing(b.prev)
        # deleted first undeleted basis element
        @assert b == B.first_undeleted
        B.first_undeleted = b.next
    else
        @assert b > B.first_undeleted
        @assert !isdeleted(b.prev) && b.prev.next == b
        if isnothing(b.next)
            # deleted last undeleted element
            @assert b == B.last_undeleted
            b.prev.next = nothing
        else
            @assert !isdeleted(b.next) && b < b.next
            b.prev.next = b.next
        end
    end

    if isnothing(b.next)
        # deleted last undeleted element
        @assert b == B.last_undeleted
        B.last_undeleted = b.prev
        if b < B.last
            # deleted not last element
            b.next = B.last
        end
    else
        @assert b <= B.last_undeleted && b < B.last
        @assert !isdeleted(b.next) && b.next.prev == b
        b.next.prev = b.prev
    end

    B.deleted += 1
    b.deleted = true
    b.vector = replacement
end


"""
    hasnext(b::BasisElement)

Return `true` if there is another (undeleted) basis element after `b` in its basis regarding the order of the basis. 
"""
function hasnext(b::BasisElement)
    l = last(basis(b))
    return !isnothing(l) && b < l
end


"""
    next(b::BasisElement)

Return the next (undeleted) basis element after `b` in its basis regarding the order of the basis or `nothing` if `b` was the last. 
"""
function next(b::BasisElement)
    if isdeleted(b)
        hasnext(b) || return nothing

        # find the next undeleted element
        next_undeleted = b.next
        while isdeleted(next_undeleted)
            next_undeleted = next_undeleted.next
        end

        # update path
        var = b
        while isdeleted(var)
            tmp = var.next
            var.next = next_undeleted
            var = tmp
        end

        return next_undeleted
    else
        return b.next
    end
end


"""
    hasprevious(b::BasisElement)

Return `true` if there is another (undeleted) basis element before `b` in its basis regarding the order of the basis. 
"""
function hasprevious(b::BasisElement)
    f = first(basis(b))
    return !isnothing(f) && f < b
end


"""
    previous(b::BasisElement)

Return the previous (undeleted) basis element before `b` in its basis regarding the order of the basis or `nothing` if `b` was the first. 
"""
function previous(b::BasisElement)
    if isdeleted(b)
        hasprevious(b) || return nothing

        # find the previous undeleted element
        prev_undeleted = b.prev
        while isdeleted(prev_undeleted)
            prev_undeleted = prev_undeleted.prev
        end

        # update path
        var = b
        while isdeleted(var)
            tmp = var.prev
            var.prev = prev_undeleted
            var = tmp
        end

        return prev_undeleted
    else
        return b.prev
    end
end


"""
    Vector(v::AbstractBasisVector{T}) where {T}

Convert `v` to a dense julia vector with entries corresponding to the current state of the basis.
"""
function Vector(v::AbstractBasisVector{T}) where {T}
    B = basis(v)
    R = base_ring(B)

    i = length(B)
    b = last(B)
    result = Vector{T}(undef, i)

    for t in v
        c = elem(t)
        λ = coeff(t)

        # fill result with zeros until next entry in v with non-zero coefficient
        while b > c
            result[i] = zero(R)
            b = b.prev
            i -= 1
        end

        result[i] = λ
        b = b.prev
        i -= 1
    end

    # fill remainder of result with zeros
    for j = 1:i
        result[j] = zero(R)
    end

    return result
end


"""
    Vector(b::BasisElement)

Convert the internal vector representation of `b` to a dense julia vector with entries corresponding to the current state of the basis.
"""
# Vector(b::BasisElement) = Vector(vector(b))


"""
    SparseVector(v::AbstractBasisVector{T}) where {T}

Convert `v` to a sparse julia vector with entries corresponding to the current state of the basis.
"""
function SparseVector(v::AbstractBasisVector{T}) where {T}
    B = basis(v)
    I = Vector{Int}()
    V = Vector{T}()

    i = length(B)
    b = last(B)

    for t in v
        c = elem(t)
        λ = coeff(t)

        # skip basis elements with coefficient zero in v
        while b > c
            b = b.prev
            i -= 1
        end

        push!(I, i)
        push!(V, λ)
    end

    return sparsevec(I, V, length(B))
end


"""
    SparseVector(b::BasisElement)

Convert the internal vector representation of `b` to a sparse julia vector with entries corresponding to the current state of the basis.
"""
# SparseVector(b::BasisElement) = SparseVector(vector(b))